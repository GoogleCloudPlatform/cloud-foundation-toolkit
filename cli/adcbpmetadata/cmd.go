package adcbpmetadata

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"

	"github.com/GoogleCloudPlatform/cloud-foundation-toolkit/cli/bpmetadata"
	"github.com/hashicorp/hcl/v2/hclparse"
	"github.com/hashicorp/terraform-config-inspect/tfconfig"
	"github.com/spf13/cobra"
	"github.com/spf13/viper"
)

var flags struct {
	rootModulePath string
	validate_only  bool
}

// Logger interface to make Log injectable/mockable
type Logger interface {
	Info(args ...interface{})
	Warn(args ...interface{})
	Error(args ...interface{})
}


func init() {
	viper.AutomaticEnv()
	Cmd.Flags().StringVarP(&flags.rootModulePath, "path", "p", ".", "Path to the blueprint for generating metadata.")
	Cmd.Flags().BoolVarP(&flags.validate_only, "validate_only", "v", false, "Only validates the metadata.")
}

const (
	readmeFileName          = "README.md"
	tfVersionsFileName      = "versions.tf"
	tfRolesFileName         = "test/setup/iam.tf"
	tfServicesFileName      = "test/setup/main.tf"
	iconFilePath            = "assets/icon.png"
	modulesPath             = "modules"           // Directory name
	examplesPath            = "examples"          // Directory name
	metadataFileName        = "metadata.yaml"
	metadataDisplayFileName = "metadata.display.yaml"
	metadataApiVersion      = "blueprints.cloud.google.com/v1alpha1"
	metadataKind            = "BlueprintMetadata"
	localConfigAnnotation   = "config.kubernetes.io/local-config"
)

var Cmd = &cobra.Command{
	Use:   "adc_metadata",
	Short: "Validates and generates metadata for a Terraform module for ingestion into ADC.",
	Long:  `Validates a Terraform module and generates a metadata.yaml file compatible with ADC (Application Delivery Controller) ingestion requirements.`,
	Args:  cobra.NoArgs,
	Run:   generate,
}

// The top-level command function that generates metadata based on the provided flags
func generate(cmd *cobra.Command, args []string) {
	wdPath, err := os.Getwd()
	if err != nil {
		Log.Error("Error getting working directory:"+ err.Error())
		return
	}

	var currBpPath string
	if flags.rootModulePath != "" {
		if filepath.IsAbs(flags.rootModulePath) {
			currBpPath = flags.rootModulePath
		} else {
			currBpPath = filepath.Join(wdPath, flags.rootModulePath)
		}
	} else {
		currBpPath = wdPath
	}
	Log.Info("Operating on blueprint path:"+ currBpPath)

	if !flags.validate_only {
		Log.Info("Generation Mode: Starting module validation and metadata generation...") // Corrected log message
		err = ValidateRootModuleForADC(currBpPath, true)
		if err != nil {
			Log.Error("Error while validating Terraform module:"+ err.Error())
			return
		}

		Log.Info("\n**************** Generating "+ metadataFileName + " ****************")
		err = bpmetadata.GenerateMetadataForBpPath(currBpPath)
		if err != nil {
			Log.Error("Error while generating "+ metadataFileName+":"+ err.Error())
			return
		}
		Log.Info("\n**************** Done Generating " + metadataFileName + " ****************\n")
	} else {
		Log.Info("Validate-Only Mode: Skipping module validation and metadata generation.")
	}

		err = validateMetadataYamlForADC(currBpPath)
		if err !=nil{
			Log.Error("Error: "+ err.Error())
		}

	// No explicit return needed here
}

func validateMetadataYamlForADC(currBpPath string) error {
	Log.Info("**************** Validating "+ metadataFileName+ " ****************")

	// 1. Validate metadata.yaml against schema
	fmt.Println("Validating metadata file against schema")
	err := bpmetadata.ValidateMetadata(currBpPath, "")
	if err != nil {
		return fmt.Errorf("failed to validate %s against schema: %w", metadataFileName, err)
	}

	bpObj, err := bpmetadata.UnmarshalMetadata(currBpPath, metadataFileName)
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return fmt.Errorf("%s file does not exist in path %s: %w", metadataFileName, currBpPath, err)
		}
		return fmt.Errorf("failed to unmarshal %s: %w", metadataFileName, err)
	}

	if bpObj == nil {
		return fmt.Errorf("unmarshalled metadata object is nil from %s (path: %s) without an explicit error", metadataFileName, currBpPath)
	}

	var validationErrors []string

	if bpObj.Spec == nil {
		validationErrors = append(validationErrors, "spec section is missing from "+metadataFileName)
	} else {
		if bpObj.Spec.Info == nil {
			validationErrors = append(validationErrors, "spec.info section is missing")
		} else if bpObj.Spec.Info.Version == "" {
			validationErrors = append(validationErrors, "spec.info.version is missing")
		}

		if bpObj.Spec.Requirements == nil {
			validationErrors = append(validationErrors, "spec.requirements section is missing. This section can be generated by adding respective configurations (e.g., test/setup/iam.tf for roles, test/setup/main.tf for services, versions.tf for provider versions or manually.")
		} else {
			if len(bpObj.Spec.Requirements.Services) == 0 {
				validationErrors = append(validationErrors,
					fmt.Sprintf("spec.requirements.services are missing. Add service configurations in %s or add manually.", tfServicesFileName))
				}
			if len(bpObj.Spec.Requirements.Roles) == 0 {
				validationErrors = append(validationErrors,
					fmt.Sprintf("spec.requirements.roles are missing. Add role configurations in %s or add manually.", tfRolesFileName))
			}
			if len(bpObj.Spec.Requirements.ProviderVersions) == 0 {
				if !flags.validate_only {
					Log.Info("Attempting to generate provider versions from " + tfVersionsFileName)
					// Use filepath.Join for OS-agnostic path construction
					versionsFilePath := filepath.Join(currBpPath, tfVersionsFileName)

					if _, statErr := os.Stat(versionsFilePath); os.IsNotExist(statErr) {
						validationErrors = append(validationErrors, fmt.Sprintf("spec.requirements.providerVersions is missing, and %s file was not found at %s to generate them.", tfVersionsFileName, versionsFilePath))
					} else {
						// TODO: We can add a fallback where we can pickup versions from main.tf also and verify the vesion if ADC supports that
						p := hclparse.NewParser()
						versionsFile, diags := p.ParseHCLFile(versionsFilePath)
						if diags.HasErrors() {
							var hclErrs []string
							for _, diag := range diags {
								hclErrs = append(hclErrs, diag.Error())
							}
							validationErrors = append(validationErrors, fmt.Sprintf("errors parsing %s: %s", tfVersionsFileName, strings.Join(hclErrs, "; ")))
						} else {
							versionObj, parseErr := bpmetadata.ParseBlueprintProviderVersions(versionsFile)
							if parseErr != nil {
								validationErrors = append(validationErrors, fmt.Sprintf("error parsing blueprint provider versions from %s: %s", tfVersionsFileName, parseErr.Error()))
							} else if len(versionObj) == 0 {
								validationErrors = append(validationErrors, fmt.Sprintf("no provider versions found or parsed from %s. Ensure the file has valid provider requirements.", tfVersionsFileName))
							} else {
								bpObj.Spec.Requirements.ProviderVersions = versionObj
								Log.Info("Successfully generated and assigned provider versions.")
								writeErr := bpmetadata.WriteMetadata(bpObj, currBpPath, metadataFileName)
								if writeErr != nil {
									return fmt.Errorf("error writing updated provider version information into %s: %w", metadataFileName, writeErr)
								}
								Log.Info("Successfully wrote updated metadata with provider versions to "+ metadataFileName)
							}
						}
					}
				} else {
					validationErrors = append(validationErrors,
						fmt.Sprintf("spec.requirements.providerVersions is missing. Generate by adding configuration in %s and re-running without validate_only, or add manually.", tfVersionsFileName))
				}
			}
		}

		if bpObj.Spec.Interfaces == nil {
			validationErrors = append(validationErrors, "spec.interfaces section is missing")
		} else {
			var connectionMetadataExists bool
			for _, variable := range bpObj.Spec.Interfaces.Variables {
				if len(variable.Connections) > 0 {
					connectionMetadataExists = true
					break
				}
			}
			if !connectionMetadataExists && len(bpObj.Spec.Interfaces.Variables) > 0 {
				Log.Warn("Connection data is missing from spec.interfaces.variables in "+ metadataFileName + ". Manual update may be needed.")
			}
			for _, output := range bpObj.Spec.Interfaces.Outputs {
				if output.Type == nil {
					validationErrors = append(validationErrors, fmt.Sprintf("output '%s' in spec.interfaces.outputs is missing type information", output.Name))
				}
			}
		}
	}

	if len(validationErrors) > 0 {
		return fmt.Errorf("%s validation errors:\n- %s", metadataFileName, strings.Join(validationErrors, ",\n- "))
	}

	Log.Info("**************** Done validating "+ metadataFileName + " ****************")
	return nil
}

// ValidateRootModuleForADC validates the root Terraform module for ADC requirements.
// If generateMetadata is true, it may also create or update the README.md file.
func ValidateRootModuleForADC(bpPath string, generateMetadata bool) error {
	Log.Info("**************** Validating Terraform Root Module ****************")

	readmeFilePath := filepath.Join(bpPath, readmeFileName)
	missingReadme := checkFilePresence(bpPath, []string{readmeFileName})

	if generateMetadata {
		// Create or update readme only when mode is generate
		defaultTitle := "Add your title here"
		if len(missingReadme) == 0 { // README.md exists
			readmeContentByte, err := extractReadmeData(readmeFilePath)
			if err != nil {
				return fmt.Errorf("failed to read existing README.md at %s: %w", readmeFilePath, err)
			}

			_, err = bpmetadata.GetMdContent(readmeContentByte, 1, 1, "", false)
			var titlePrependTemplate string
			if err != nil {
				// If err is not nil then an H1 Title is not present in the existing readme.
				Log.Info("README.md file is missing an H1 title, prepending a placeholder title.")
				// Define a temporary template to prepend the title to existing data.
				titlePrependTemplate = `
# {{.Title}}
{{.Data}}
					`
					pageDataForPrepend := PageData{
						Title: defaultTitle,
						Data:  string(readmeContentByte),
					}
					// Call createReadme with the custom template for prepending.
					err = createReadme(bpPath, pageDataForPrepend, titlePrependTemplate)
					if err !=nil {
						return err
					}
			}
		} else {
			Log.Info("README.md is missing, creating a new one with a placeholder title and skeleton structure.")
			// Create PageData with only the default title; .Data will be empty.
			// The global mdTemplate will be used, which doesn't use .Data but uses .Title.
			pageDataForNewReadme := PageData{Title: defaultTitle}
			err := createReadme(bpPath, pageDataForNewReadme, "") // Pass empty template string to use mdTemplate
			if err !=nil {
				return err
			}
		}
	} else {
		Log.Info("Validate-Only Mode: Validating existing README.md.")
		// If README is missing in validate-only mode, validateReadme will return an error.
		err := validateReadme(readmeFilePath)
		if err != nil {
			return fmt.Errorf("README.md validation failed: %w", err)
		}
	}

	// Validate presence of other required files like main.tf, versions.tf
	requiredFilesForRoot := []string{"main.tf", tfVersionsFileName}
	missingRequiredFiles := checkFilePresence(bpPath, requiredFilesForRoot)
	if len(missingRequiredFiles) > 0 {
		return fmt.Errorf("top-level module at %s must have the following files: %s", bpPath, strings.Join(missingRequiredFiles, ", "))
	}

	// Check for other optional but recommended files
	otherFiles := []string{iconFilePath, examplesPath, filepath.Join("test", "setup", "iam.tf"), filepath.Join("test", "setup", "main.tf")}
	missingOtherFiles := checkFilePresence(bpPath, otherFiles)
	if len(missingOtherFiles) > 0 {
		Log.Info("For a comprehensive blueprint at ", bpPath, ", consider adding these optional files/directories: [", strings.Join(missingOtherFiles, ", "), "]")
	}

	// Validate versions.tf content
	err := validateVersionsFiles(filepath.Join(bpPath, tfVersionsFileName)) // Assuming validateVersionsFiles is defined elsewhere
	if err != nil {
		return fmt.Errorf("versions.tf validation failed: %w", err)
	}
	Log.Info("**************** Root Module Validation Successful ****************\n")
	return nil
}

func validateVersionsFiles(versionsConfigPath string) error {
	Log.Info("Validating "+ tfVersionsFileName+ " at "+ versionsConfigPath)
	allowedTerraformProviders := []string{
		"hashicorp/google", "hashicorp/google-beta",
	}

	p := hclparse.NewParser()
	versionsFile, diags := p.ParseHCLFile(versionsConfigPath)
	if err := bpmetadata.HasHclErrors(diags); err != nil {
		return fmt.Errorf("HCL parsing errors in %s: %w", versionsConfigPath, err)
	}

	var hclModule tfconfig.Module
	hclModule.RequiredProviders = make(map[string]*tfconfig.ProviderRequirement)
	diags = tfconfig.LoadModuleFromFile(versionsFile, &hclModule)
	if err := bpmetadata.HasHclErrors(diags); err != nil {
		return fmt.Errorf("errors loading module from %s: %w", versionsConfigPath, err)
	}

	var validationErrs []string
	if len(hclModule.RequiredProviders) == 0 {
		validationErrs = append(validationErrs, "no required_providers block found in "+versionsConfigPath)
	}

	for providerName, providerData := range hclModule.RequiredProviders {
		if providerData.Source == "" {
			validationErrs = append(validationErrs, fmt.Sprintf("provider '%s' is missing 'source' attribute in %s", providerName, versionsConfigPath))
		} else if slices.Index(allowedTerraformProviders, providerData.Source) == -1 {
			validationErrs = append(validationErrs, fmt.Sprintf("disallowed Terraform provider source '%s' for provider '%s' in %s. Allowed: [%s]",
				providerData.Source, providerName, versionsConfigPath, strings.Join(allowedTerraformProviders, ", ")))
		}
		if len(providerData.VersionConstraints) == 0 {
			validationErrs = append(validationErrs, fmt.Sprintf("version constraint is missing for provider '%s' (source: '%s') in %s",
				providerName, providerData.Source, versionsConfigPath))
		}
	}

	if len(validationErrs) > 0 {
		return fmt.Errorf(strings.Join(validationErrs, "\n"))
	}

	Log.Info("Done Validating "+ tfVersionsFileName)
	return nil
}

// checkFilePresence checks if the given file names exist within bpPath.
// Returns a slice of basenames of files that are missing or encountered an error during stat.
func checkFilePresence(bpPath string, fileNames []string) []string {
	var missingFiles []string
	for _, fileName := range fileNames {
		// Use filepath.Join for OS-agnostic path construction
		filePath := filepath.Join(bpPath, fileName)
		_, err := os.Stat(filePath)
		if err != nil {
			// os.IsNotExist(err) is a more specific check for "file does not exist".
			// Current logic flags any error (e.g. permission denied) as if the file is missing.
			missingFiles = append(missingFiles, fileName)
		}
	}
	return missingFiles
}
